# 工业上位机：三部分设备 ROS2 + C++ SDK 控制架构说明

## 一、项目概览

本项目为**工业上位机 ROS2 工作区**，目标是通过 ROS2 和各自厂商的 C++ SDK 统一控制三部分设备：

| 部分 | 设备 | C++ SDK 位置 | ROS2 封装包 | 通信方式 |
|------|------|--------------|-------------|----------|
| **1. 手套** | 动捕手套 (HandDriver) | `HandDriver_Linux_Cpp_Angle_Proj_202507041730` (UDEServer) | `glove_node` | UDP 5555 |
| **2. 灵手** | LHandPro 灵手 | `lhandpro_service/thirdparty` (LHandProLib) | `lhandpro_service` | EtherCAT (SOEM) |
| **3. 机械臂** | DuCo 机械臂 | `duco_ros2_driver/src/duco_ros_driver` (DuCo SDK) | `duco_ros_driver` | 厂商协议 / TCP |

---

## 二、三部分与 C++ SDK 对应关系

### 1. 手套 (Glove)

- **SDK**：`HandDriver_Linux_Cpp_Angle_Proj_202507041730`
  - 核心类：`UDEGloveSDK`（见 `glove_node` 中 `UDEServer.h` / `UDEServer.cxx`）
  - 接口：`SetPortNum(5555)`、`StartListening()`、`GetRoleNameList()`、`GetVecFingerData(role)` 等
- **ROS2 节点**：`glove_node`
  - 发布话题：`glove/joints`（类型 `common_msgs/msg/GloveJoints`）
  - 50Hz 定时器读取 SDK 并发布关节数据

### 2. 灵手 (LHandPro)

- **SDK**：`lhandpro_service/thirdparty` 下的 **LHandProLib**（`LHandProLib.hpp`）
  - 通信：EtherCAT，依赖 SOEM 子模块
  - 接口：使能、位置/速度/电流控制、回零、多关节运动等
- **ROS2 节点**：`lhandpro_service`（`HandControlService`）
  - 提供大量服务：`set_enable`、`set_position`、`move_motors`、`home_motors`、`get_now_angle` 等（见 `lhandpro_interfaces/srv/`）

### 3. 机械臂 (DuCo)

- **SDK**：DuCo 官方 C++ SDK，由 `duco_ros2_driver/src/duco_ros_driver` 封装
  - 接口：`power_on`、`enable`、`movej`、`movej_pose`、`movel`、`set_standard_digital_out` 等（见 duco_ros2_driver/README.md）
- **ROS2 节点**：`duco_ros_driver`（需在 `duco_ros2_driver` 工作区内单独编译）
  - 服务：`/duco_robot/robot_control`、`/duco_robot/robot_move`、`/duco_robot/robot_io_control`
  - 话题：`/duco_robot/robot_state`（`duco_msg/msg/DucoRobotState`）

---

## 三、当前上位机逻辑

- **system_controller**：目前只做 **UI → DuCo** 的转发
  - 订阅：`/duco_robot/robot_state`
  - 调用 DuCo：`/duco_robot/robot_move`、`robot_control`、`robot_io_control`
  - 对 UI 暴露：`/ui/request_move`、`/ui/request_control`、`/ui/request_io`（带安全与忙检测）
- **ui_app**：仅通过 `RosNode` 调用上述 `/ui/request_*` 服务，即**只控制机械臂**，未直接对接手套与灵手。

因此，**三部分设备都已通过各自 C++ SDK 接入 ROS2**，但**上位机（system_controller + ui_app）目前只统一了 DuCo 机械臂**，手套和灵手是独立节点，尚未在“一个上位机”里统一调度。

---

## 四、实现“上位机统一控制三部分”的推荐做法

### 方案 A：在现有架构上扩展（推荐）

1. **保持三部分 ROS2 封装不变**
   - 手套：`glove_node`（SDK：UDEServer）
   - 灵手：`lhandpro_service`（SDK：LHandProLib）
   - 机械臂：`duco_ros_driver`（SDK：DuCo）

2. **扩展 system_controller 为“三部分协调器”**
   - 在 `system_controller` 中增加：
     - 对 **手套**：订阅 `glove/joints`，可选地转发、滤波或供其他节点使用；若需“控制”，可订阅 `common_msgs/msg/HandCmd` 等（若有）或仅做状态汇总。
     - 对 **灵手**：调用 `lhandpro_interfaces` 的服务（如 `set_enable`、`set_position`、`move_motors`），可封装为 `/ui/request_hand_*` 一类统一服务供 UI 使用。
     - 对 **机械臂**：保持现有 `/ui/request_move`、`/ui/request_control`、`/ui/request_io`。
   - 这样，**上位机 = system_controller**，通过 ROS2 统一访问三部分的 C++ SDK 封装，无需直接链接三套 SDK。

3. **扩展 ui_app**
   - 在 UI 中增加灵手、手套的显示与控制入口（调用上述 `/ui/request_hand_*` 或订阅 `glove/joints` 显示）。

4. **一键启动**
   - 写一个 launch 文件，同时启动：
     - `glove_node`
     - `lhandpro_service`
     - DuCo 驱动（`duco_ros_driver`）
     - `system_controller`
     - `ui_app`
   - 若 duco_ros_driver 在另一工作区，可在一个 launch 里用 `IncludeLaunchDescription` 引入其 launch，或先 `source` 再启动。

### 方案 B：单独建一个“三部分上位机”包

- 新建包如 `hmi_controller`，依赖：
  - `common_msgs`（手套）
  - `lhandpro_interfaces`（灵手）
  - `duco_msg`（机械臂）
- 该包只做：
  - 订阅/调用三部分的 topic 和 service；
  - 对 UI 或其它节点提供统一 topic/service。
- 三部分的 C++ SDK 仍只由现有节点（glove_node、lhandpro_service、duco_ros_driver）封装，**不在此新包中直接链接 SDK**。

---

## 五、总结

- **三部分机器**：手套（HandDriver）、灵手（LHandPro）、DuCo 机械臂，均已通过**各自 C++ SDK + ROS2 节点**接入。
- **做“上位机”控制三部分**的正确方式：  
  **不在一处同时链接三套 SDK**，而是：
  1. 保持三个节点分别封装三套 C++ SDK；
  2. 用 **system_controller（或新建 hmi_controller）** 通过 ROS2 的 topic/service **统一协调**三部分；
  3. UI 只与 system_controller（或 hmi_controller）的 ROS2 接口通信。

这样既清晰可维护，又符合“ROS2 + 各设备 C++ SDK”的分层设计。若你希望，我可以按方案 A 写出 `system_controller` 扩展灵手/手套接口的示例代码和 launch 示例。
